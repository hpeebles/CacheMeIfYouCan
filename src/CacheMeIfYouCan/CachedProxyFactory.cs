using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading.Tasks;

namespace CacheMeIfYouCan
{
    public class CachedProxyFactory
    {
        private static readonly ModuleBuilder ModuleBuilder;
        
        static CachedProxyFactory()
        {
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyFactoryAsm"), AssemblyBuilderAccess.Run);
            ModuleBuilder = assemblyBuilder.DefineDynamicModule("MainModule");
        }

        internal static T Build<T>(T impl, CachedProxyConfig config)
        {
            var interfaceType = typeof(T);

            ValidateType(interfaceType);
            
            var newTypeName = GetProxyName(interfaceType);

            var newType = CreateType(interfaceType, newTypeName);

            return (T)Activator.CreateInstance(newType, impl, config);
        }

        // The IL generated here is based on the IL generated by SampleProxyILTemplate
        private static Type CreateType(Type interfaceType, string name)
        {
            var typeBuilder = ModuleBuilder.DefineType(name, TypeAttributes.Class | TypeAttributes.Public);
            typeBuilder.AddInterfaceImplementation(interfaceType);
            
            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[] { interfaceType, typeof(CachedProxyConfig) });

            var ctorGen = ctorBuilder.GetILGenerator();

            foreach (var methodInfo in interfaceType.GetMethods())
            {
                // TK
                var parameterType = methodInfo.GetParameters().First().ParameterType;
                
                // Task<TV>
                var returnType = methodInfo.ReturnType;
                
                // TV
                var returnTypeInner = methodInfo.ReturnType.GenericTypeArguments.Single();

                // Create a field called _methodName of type Func<TK, Task<TV>> in which to store the cached function
                var fieldType = typeof(Func<,>).MakeGenericType(parameterType, returnType);
                var fieldName = $"_{Char.ToLower(methodInfo.Name[0])}{methodInfo.Name.Substring(1)}";
                var field = typeBuilder.DefineField(fieldName, fieldType, FieldAttributes.Private);
                var fieldCtor = fieldType.GetConstructor(new[] { typeof(object), typeof(IntPtr) });
                
                // FunctionCacheConfigurationManager<TK, TV>
                var configManagerType = typeof(FunctionCacheConfigurationManager<,>).MakeGenericType(parameterType, returnTypeInner);
                var configManagerTypeCtor = configManagerType.GetConstructor(
                    BindingFlags.Instance | BindingFlags.NonPublic,
                    null,
                    new[] { fieldType, typeof(string), typeof(CachedProxyConfig) },
                    new ParameterModifier[0]);
                
                // Build a cached version of the function and store it in the newly created field
                ctorGen.Emit(OpCodes.Ldarg_0); // this
                ctorGen.Emit(OpCodes.Ldarg_1); // T impl
                ctorGen.Emit(OpCodes.Dup);
                ctorGen.Emit(OpCodes.Ldvirtftn, methodInfo); // impl.MethodName
                ctorGen.Emit(OpCodes.Newobj, fieldCtor); // Func<TK, Task<TV>> .ctor(object, IntPointer)
                ctorGen.Emit(OpCodes.Ldstr, methodInfo.Name); // MethodName
                ctorGen.Emit(OpCodes.Ldarg_2); // CachedProxyConfig config
                ctorGen.Emit(OpCodes.Newobj, configManagerTypeCtor); // FunctionCacheConfigurationManager .ctor(Func<TK, Task<TV>>, string, CachedProxyConfig)
                ctorGen.Emit(OpCodes.Call, configManagerType.GetMethod("Build")); // FunctionCacheConfigurationManager.Build()
                ctorGen.Emit(OpCodes.Stfld, field); // Store result in _methodName
                
                // Build a method to implement the interface method by calling the function stored in the newly created field
                var methodBuilder = typeBuilder.DefineMethod(
                    methodInfo.Name,
                    MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                    methodInfo.ReturnType,
                    new[] { parameterType });
                
                var methodGen = methodBuilder.GetILGenerator();
                
                methodGen.Emit(OpCodes.Ldarg_0); // this
                methodGen.Emit(OpCodes.Ldfld, field); // _methodName
                methodGen.Emit(OpCodes.Ldarg_1); // TK key
                methodGen.Emit(OpCodes.Callvirt, fieldType.GetMethod("Invoke", new[] { parameterType })); // _methodName.Invoke(key)
                methodGen.Emit(OpCodes.Ret); // Return result
            }
            
            ctorGen.Emit(OpCodes.Ret);

            return typeBuilder.CreateTypeInfo();
        }

        private static void ValidateType(Type type)
        {
            if (!type.IsInterface)
                throw new InvalidOperationException("<T> must be an interface");

            foreach (var methodInfo in type.GetMethods())
            {
                var parameters = methodInfo.GetParameters();
                if (parameters.Length != 1)
                    throw new Exception("Method must have exactly 1 input");

                var returnType = methodInfo.ReturnType;
                if (returnType.GetGenericTypeDefinition() != typeof(Task<>))
                    throw new Exception("Method must return Task<T>");
            }
        }

        private static string GetProxyName(Type type)
        {
            var name = $"{type.Namespace}.{type.Name.Remove(0, type.Name.StartsWith("I") ? 1 : 0)}Proxy_{Guid.NewGuid()}";

            return name;
        }
    }
}