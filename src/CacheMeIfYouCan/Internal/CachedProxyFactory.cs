using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using CacheMeIfYouCan.Configuration;

// Each type built by this class gets put into a dynamically built assembly called CachedProxyFactoryAsm
[assembly: InternalsVisibleTo("CachedProxyFactoryAsm")]
namespace CacheMeIfYouCan.Internal
{
    internal class CachedProxyFactory
    {
        private static readonly ModuleBuilder ModuleBuilder;
        
        static CachedProxyFactory()
        {
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(
                new AssemblyName("CachedProxyFactoryAsm"),
                AssemblyBuilderAccess.Run);
            
            ModuleBuilder = assemblyBuilder.DefineDynamicModule("MainModule");
        }

        internal static T Build<T>(T impl, CachedProxyConfig config)
        {
            var interfaceType = typeof(T);

            if (!interfaceType.IsInterface)
                throw new InvalidOperationException("<T> must be an interface");
            
            var newType = CreateType(interfaceType);

            return (T)Activator.CreateInstance(newType, impl, config);
        }

        // The IL generated here is based on the IL generated by SampleProxyILTemplate
        private static Type CreateType(Type interfaceType)
        {
            var typeName = GetProxyName(interfaceType);

            var typeBuilder = ModuleBuilder.DefineType(typeName, TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed);
            typeBuilder.AddInterfaceImplementation(interfaceType);
            
            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[] { interfaceType, typeof(CachedProxyConfig) });

            var ctorGen = ctorBuilder.GetILGenerator();
            
            ctorGen.DeclareLocal(typeof(MemberInfo[]));

            ctorGen.Emit(OpCodes.Ldarg_0); // this
            ctorGen.Emit(OpCodes.Call, typeof(Object).GetConstructor(new Type[0]));
            
            // Create a field called _impl of type T in which to store the underlying interface implementation
            var implField = typeBuilder.DefineField("_impl", interfaceType, FieldAttributes.Private);
            
            ctorGen.Emit(OpCodes.Ldarg_0);
            ctorGen.Emit(OpCodes.Ldarg_1);
            ctorGen.Emit(OpCodes.Stfld, implField);
            
            ctorGen.Emit(OpCodes.Ldtoken, interfaceType);
            ctorGen.Emit(OpCodes.Call, typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle), new[] { typeof(RuntimeTypeHandle) }));
            ctorGen.Emit(OpCodes.Call, typeof(InterfaceMethodsResolver).GetMethod(nameof(InterfaceMethodsResolver.GetAllMethods), new[] { typeof(Type) }));
            ctorGen.Emit(OpCodes.Stloc_0);

            var methods = InterfaceMethodsResolver.GetAllMethods(interfaceType);
            
            var propertyBuilders = new Dictionary<string, PropertyBuilder>();

            for (var index = 0; index < methods.Length; index++)
            {
                var methodInfo = methods[index];

                var canBeCached = ValidateMethod(methodInfo, out var definition);

                if (canBeCached)
                {
                    // Create a field called _methodName of type Func<TK, Task<TV>> in which to store the cached function
                    var fieldName = $"_{Char.ToLower(methodInfo.Name[0])}{methodInfo.Name.Substring(1)}_{index}";
                    var field = typeBuilder.DefineField(fieldName, definition.FuncType, FieldAttributes.Private);
                    var fieldCtor = definition.FuncType.GetConstructor(new[] {typeof(object), typeof(IntPtr)});

                    // Get the relevant configuration manager type based on whether the func is single key or enumerable key
                    // and sync or async
                    var configManagerType = GetConfigManagerType(definition);
                    var configManagerTypeCtor = configManagerType.GetConstructor(
                        BindingFlags.Instance | BindingFlags.NonPublic,
                        null,
                        new[] {definition.FuncType, typeof(CachedProxyConfig), typeof(MethodInfo)},
                        new ParameterModifier[0]);

                    // Build a cached version of the function and store it in the newly created field
                    ctorGen.Emit(OpCodes.Ldarg_0); // this
                    ctorGen.Emit(OpCodes.Ldarg_1); // T impl
                    ctorGen.Emit(OpCodes.Dup);
                    ctorGen.Emit(OpCodes.Ldvirtftn, methodInfo); // impl.MethodName
                    ctorGen.Emit(OpCodes.Newobj, fieldCtor); // Func<TK, Task<TV>> .ctor(object, IntPointer)
                    ctorGen.Emit(OpCodes.Ldarg_2); // CachedProxyConfig config
                    ctorGen.Emit(OpCodes.Ldloc_0);
                    ctorGen.Emit(OpCodes.Ldc_I4, index);
                    ctorGen.Emit(OpCodes.Ldelem_Ref);
                    ctorGen.Emit(OpCodes.Newobj, configManagerTypeCtor); // FunctionCacheConfigurationManager .ctor(Func<TK, Task<TV>>, string, CachedProxyConfig)
                    ctorGen.Emit(OpCodes.Call, configManagerType.GetMethod("Build")); // FunctionCacheConfigurationManager.Build()
                    ctorGen.Emit(OpCodes.Stfld, field); // Store result in _methodName

                    // Build a method to implement the interface method by calling the function stored in the newly created field
                    var methodBuilder = typeBuilder.DefineMethod(
                        methodInfo.Name,
                        MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                        methodInfo.ReturnType,
                        definition.ParameterTypes);

                    var methodGen = methodBuilder.GetILGenerator();

                    methodGen.Emit(OpCodes.Ldarg_0); // this
                    methodGen.Emit(OpCodes.Ldfld, field); // _methodName

                    for (var i = 1; i <= definition.ParameterTypes.Length; i++)
                        methodGen.Emit(OpCodes.Ldarg, i); // Load each of the keys

                    methodGen.Emit(OpCodes.Callvirt, definition.FuncType.GetMethod("Invoke", definition.ParameterTypes)); // _methodName.Invoke(key)
                    methodGen.Emit(OpCodes.Ret); // Return result
                }
                else
                {
                    if (!DefaultSettings.Cache.InterfacesWithUnsupportedMethodsAllowed)
                    {
                        var message =
                            $"Interface contains a method which is not supported: '{interfaceType.Name}.{methodInfo.Name}'." +
                            "You can allow unsupported methods by calling DefaultSettings.Cache.AllowInterfacesWithUnsupportedMethods, " +
                            "for unsupported methods the underlying implementation will be called on every request.";

                        throw new Exception(message);
                    }

                    var methodAttributes = MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual;
                    var isPropertyAccessor = IsPropertyAccessor(methodInfo, out var property, out var accessorType);
                    PropertyBuilder propertyBuilder = null;
                    
                    if (isPropertyAccessor)
                    {
                        if (!propertyBuilders.TryGetValue(property.Name, out propertyBuilder))
                        {
                            propertyBuilder = typeBuilder.DefineProperty(
                                property.Name,
                                property.Attributes,
                                property.PropertyType,
                                null);
                            
                            propertyBuilders.Add(property.Name, propertyBuilder);
                        }

                        methodAttributes |= MethodAttributes.SpecialName;
                    }

                    var parameters = methodInfo.GetParameters();
                    
                    // Build a method to implement the interface method by calling the function stored in the newly created field
                    var methodBuilder = typeBuilder.DefineMethod(
                        methodInfo.Name,
                        methodAttributes,
                        methodInfo.ReturnType,
                        parameters.Select(p => p.ParameterType).ToArray());

                    var methodGen = methodBuilder.GetILGenerator();

                    methodGen.Emit(OpCodes.Ldarg_0); // this
                    methodGen.Emit(OpCodes.Ldfld, implField); // _impl

                    for (var i = 1; i <= parameters.Length; i++)
                        methodGen.Emit(OpCodes.Ldarg, i);

                    methodGen.Emit(OpCodes.Callvirt, methodInfo);
                    methodGen.Emit(OpCodes.Ret);

                    if (!isPropertyAccessor)
                        continue;
                    
                    if (accessorType == PropertyAccessType.Getter)
                        propertyBuilder.SetGetMethod(methodBuilder);
                    else
                        propertyBuilder.SetSetMethod(methodBuilder);
                }
            }

            ctorGen.Emit(OpCodes.Ret);

            return typeBuilder.CreateTypeInfo();
        }

        private static bool ValidateMethod(MethodInfo methodInfo, out MethodDefinition methodDefinition)
        {
            var parameterTypes = methodInfo
                .GetParameters()
                .Select(p => p.ParameterType)
                .ToArray();

            var hasCancellation = parameterTypes.Length > 1 && parameterTypes.Last() == typeof(CancellationToken);

            var maxParameters = hasCancellation ? 5 : 4;
            
            if (parameterTypes.Length == 0 ||
                parameterTypes.Length > maxParameters ||
                methodInfo.ReturnType == typeof(void))
            {
                methodDefinition = default;
                return false;
            }

            var isAsync = typeof(Task).IsAssignableFrom(methodInfo.ReturnType) && methodInfo.ReturnType.IsGenericType;

            var returnType = methodInfo.ReturnType;
            var returnTypeInner = isAsync
                ? returnType.GenericTypeArguments.Single()
                : returnType;

            var isEnumerableKey = IsEnumerableKeyFunc(out var keyType, out var valueType);

            var funcTypes = parameterTypes
                .Concat(new[] { returnType })
                .ToArray();

            Type funcTypeGeneric;
            switch (funcTypes.Length)
            {
                case 2:
                    funcTypeGeneric = typeof(Func<,>);
                    break;

                case 3:
                    funcTypeGeneric = typeof(Func<,,>);
                    break;

                case 4:
                    funcTypeGeneric = typeof(Func<,,,>);
                    break;

                case 5:
                    funcTypeGeneric = typeof(Func<,,,,>);
                    break;

                case 6 when hasCancellation:
                    funcTypeGeneric = typeof(Func<,,,,,>);
                    break;

                default:
                    methodDefinition = default;
                    return false;
            }

            var funcType = funcTypeGeneric.MakeGenericType(funcTypes);
            
            methodDefinition = new MethodDefinition
            {
                FuncType = funcType,
                ParameterTypes = parameterTypes,
                ReturnType = returnType,
                ReturnTypeInner = returnTypeInner,
                KeyType = keyType,
                ValueType = valueType,
                IsEnumerableKey = isEnumerableKey,
                IsAsync = isAsync,
                HasCancellation = hasCancellation
            };

            return true;

            bool IsEnumerableKeyFunc(out Type _keyType, out Type _valueType)
            {
                var lastKeyParam = hasCancellation ? parameterTypes[parameterTypes.Length - 2] : parameterTypes.Last();
            
                if (lastKeyParam != typeof(String) &&
                    IsEnumerable(lastKeyParam, out _keyType) &&
                    IsDictionary(returnTypeInner, out var returnKeyType, out _valueType))
                {
                    if (_keyType != returnKeyType)
                        throw new Exception(@"
The key type in the returned dictionary must match the type of the items in the input parameter");

                    return true;
                }

                _keyType = null;
                _valueType = null;
                return false;
            }
        }

        private static Type GetConfigManagerType(MethodDefinition definition)
        {
            Type configManagerGenericType;
            Type[] genericTypeInputs;

            return definition.IsEnumerableKey
                ? BuildForEnumerableKey()
                : BuildForSingleKey();
            
            Type BuildForEnumerableKey()
            {
                genericTypeInputs = (definition.HasCancellation
                    ? definition.ParameterTypes.Take(definition.ParameterTypes.Length - 1)
                    : definition.ParameterTypes)
                    .Concat(new[] { definition.ReturnTypeInner, definition.KeyType, definition.ValueType })
                    .ToArray();

                switch (genericTypeInputs.Length)
                {
                    case 4:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(EnumerableKeyFunctionCacheConfigurationManagerCanx<,,,>)
                                : typeof(EnumerableKeyFunctionCacheConfigurationManagerNoCanx<,,,>)
                            : definition.HasCancellation
                                ? typeof(EnumerableKeyFunctionCacheConfigurationManagerSyncCanx<,,,>)
                                : typeof(EnumerableKeyFunctionCacheConfigurationManagerSyncNoCanx<,,,>);
                        break;
                    
                    case 5:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerCanx<,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerNoCanx<,,,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncCanx<,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncNoCanx<,,,,>);
                        break;

                    case 6:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerCanx<,,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerNoCanx<,,,,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncCanx<,,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncNoCanx<,,,,,>);
                        break;

                    case 7:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerCanx<,,,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerNoCanx<,,,,,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncCanx<,,,,,,>)
                                : typeof(MultiParamEnumerableKeyFunctionCacheConfigurationManagerSyncNoCanx<,,,,,,>);
                        break;
                
                    default:
                        throw new Exception($"Too many input parameters: '{String.Join(",", genericTypeInputs.Select(t => t.ToString()))}'");
                }

                return configManagerGenericType.MakeGenericType(genericTypeInputs);
            }

            Type BuildForSingleKey()
            {
                genericTypeInputs = (definition.HasCancellation
                    ? definition.ParameterTypes.Take(definition.ParameterTypes.Length - 1)
                    : definition.ParameterTypes)
                    .Concat(new[] { definition.ReturnTypeInner })
                    .ToArray();

                switch (genericTypeInputs.Length)
                {
                    case 2:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(SingleKeyFunctionCacheConfigurationManagerCanx<,>)
                                : typeof(SingleKeyFunctionCacheConfigurationManagerNoCanx<,>)
                            : definition.HasCancellation
                                ? typeof(SingleKeyFunctionCacheConfigurationManagerSyncCanx<,>)
                                : typeof(SingleKeyFunctionCacheConfigurationManagerSyncNoCanx<,>);
                        break;
                    
                    case 3:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerCanx<,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerNoCanx<,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerSyncCanx<,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerSyncNoCanx<,,>);
                        break;

                    case 4:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerCanx<,,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerNoCanx<,,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerSyncCanx<,,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerSyncNoCanx<,,,>);
                        break;

                    case 5:
                        configManagerGenericType = definition.IsAsync
                            ? definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerCanx<,,,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerNoCanx<,,,,>)
                            : definition.HasCancellation
                                ? typeof(MultiParamFunctionCacheConfigurationManagerSyncCanx<,,,,>)
                                : typeof(MultiParamFunctionCacheConfigurationManagerSyncNoCanx<,,,,>);
                        break;
                
                    default:
                        throw new Exception($"Too many input parameters: '{String.Join(",", genericTypeInputs.Select(t => t.ToString()))}'");
                }
                
                return configManagerGenericType.MakeGenericType(genericTypeInputs);
            }
        }

        private static bool IsPropertyAccessor(MethodInfo methodInfo, out PropertyInfo property, out PropertyAccessType type)
        {
            foreach (var prop in methodInfo.DeclaringType.GetProperties())
            {
                if (prop.GetGetMethod() == methodInfo)
                {
                    property = prop;
                    type = PropertyAccessType.Getter;
                    return true;
                }

                if (prop.GetSetMethod() == methodInfo)
                {
                    property = prop;
                    type = PropertyAccessType.Setter;
                    return true;
                }
            }

            property = default;
            type = default;
            return false;
        }

        private static string GetProxyName(Type type)
        {
            var name = $"{type.Namespace}.{type.Name.Remove(0, type.Name.StartsWith("I") ? 1 : 0)}Proxy_{Guid.NewGuid()}";

            return name;
        }
        
        private static bool IsEnumerable(Type type, out Type innerType)
        {
            foreach (var i in new[] { type }.Concat(type.GetInterfaces()))
            {
                if (i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                {
                    innerType = i.GenericTypeArguments.Single();
                    return true;
                }
            }

            innerType = null;
            return false;
        }

        private static bool IsDictionary(Type type, out Type keyType, out Type valueType)
        {
            foreach (var i in new[] { type }.Concat(type.GetInterfaces()))
            {
                if (i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IDictionary<,>))
                {
                    keyType = i.GenericTypeArguments[0];
                    valueType = i.GenericTypeArguments[1];
                    return true;
                }
            }

            keyType = null;
            valueType = null;
            return false;
        }

        private class MethodDefinition
        {
            public Type FuncType;
            public Type[] ParameterTypes;
            public Type ReturnType;
            public Type ReturnTypeInner;
            public Type KeyType; // Only populated for enumerable key functions
            public Type ValueType; // Only populated for enumerable key functions
            public bool IsEnumerableKey;
            public bool IsAsync;
            public bool HasCancellation;
        }

        private enum PropertyAccessType
        {
            Getter,
            Setter
        }
    }
}
