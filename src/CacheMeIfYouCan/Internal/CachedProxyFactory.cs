using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using CacheMeIfYouCan.Configuration;

[assembly: InternalsVisibleTo("ProxyFactoryAsm")]
[assembly: InternalsVisibleTo("CacheMeIfYouCan.Tests")]
[assembly: InternalsVisibleTo("CacheMeIfYouCan.PerformanceTests")]
namespace CacheMeIfYouCan.Internal
{
    internal class CachedProxyFactory
    {
        private static readonly ModuleBuilder ModuleBuilder;
        
        static CachedProxyFactory()
        {
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyFactoryAsm"), AssemblyBuilderAccess.Run);
            ModuleBuilder = assemblyBuilder.DefineDynamicModule("MainModule");
        }

        internal static T Build<T>(T impl, CachedProxyConfig config)
        {
            var interfaceType = typeof(T);

            ValidateType(interfaceType);
            
            var newTypeName = GetProxyName(interfaceType);

            var newType = CreateType(interfaceType, newTypeName);

            return (T)Activator.CreateInstance(newType, impl, config);
        }

        // The IL generated here is based on the IL generated by SampleProxyILTemplate
        private static Type CreateType(Type interfaceType, string name)
        {
            var typeBuilder = ModuleBuilder.DefineType(name, TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed);
            typeBuilder.AddInterfaceImplementation(interfaceType);
            
            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[] { interfaceType, typeof(CachedProxyConfig) });

            var ctorGen = ctorBuilder.GetILGenerator();
            
            ctorGen.DeclareLocal(typeof(MemberInfo[]));

            ctorGen.Emit(OpCodes.Ldarg_0); // this
            ctorGen.Emit(OpCodes.Call, typeof(Object).GetConstructor(new Type[0]));
            
            ctorGen.Emit(OpCodes.Ldtoken, interfaceType);
            ctorGen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new[] { typeof(RuntimeTypeHandle) }));
            ctorGen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetMethods", new Type[0]));
            ctorGen.Emit(OpCodes.Stloc_0);

            var methods = interfaceType.GetMethods();
            
            for (var index = 0; index < methods.Length; index++)
            {
                var methodInfo = methods[index];
                var definition = GetMethodDefinition(methodInfo);
                
                // Create a field called _methodName of type Func<TK, Task<TV>> in which to store the cached function
                var fieldName = $"_{Char.ToLower(methodInfo.Name[0])}{methodInfo.Name.Substring(1)}_{index}";
                var field = typeBuilder.DefineField(fieldName, definition.FieldType, FieldAttributes.Private);
                var fieldCtor = definition.FieldType.GetConstructor(new[] { typeof(object), typeof(IntPtr) });
                
                // Either FunctionCacheConfigurationManager<TK, TV> or MultiKeyFunctionCacheConfigurationManager
                // depending on if the key is Enumerable or not
                var configManagerType = GetConfigManagerType(definition);
                var configManagerTypeCtor = configManagerType.GetConstructor(
                    BindingFlags.Instance | BindingFlags.NonPublic,
                    null,
                    new[] { definition.FuncType, typeof(CachedProxyConfig), typeof(MethodInfo) },
                    new ParameterModifier[0]);
                
                // Build a cached version of the function and store it in the newly created field
                ctorGen.Emit(OpCodes.Ldarg_0); // this
                ctorGen.Emit(OpCodes.Ldarg_1); // T impl
                ctorGen.Emit(OpCodes.Dup);
                ctorGen.Emit(OpCodes.Ldvirtftn, methodInfo); // impl.MethodName
                ctorGen.Emit(OpCodes.Newobj, fieldCtor); // Func<TK, Task<TV>> .ctor(object, IntPointer)
                ctorGen.Emit(OpCodes.Ldarg_2); // CachedProxyConfig config
                ctorGen.Emit(OpCodes.Ldloc_0);
                ctorGen.Emit(OpCodes.Ldc_I4, index);
                ctorGen.Emit(OpCodes.Ldelem_Ref);
                ctorGen.Emit(OpCodes.Newobj, configManagerTypeCtor); // FunctionCacheConfigurationManager .ctor(Func<TK, Task<TV>>, string, CachedProxyConfig)
                ctorGen.Emit(OpCodes.Call, configManagerType.GetMethod("Build")); // FunctionCacheConfigurationManager.Build()
                ctorGen.Emit(OpCodes.Stfld, field); // Store result in _methodName
                
                // Build a method to implement the interface method by calling the function stored in the newly created field
                var methodBuilder = typeBuilder.DefineMethod(
                    methodInfo.Name,
                    MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                    methodInfo.ReturnType,
                    new[] { definition.ParameterType });
                
                var methodGen = methodBuilder.GetILGenerator();
                
                methodGen.Emit(OpCodes.Ldarg_0); // this
                methodGen.Emit(OpCodes.Ldfld, field); // _methodName
                methodGen.Emit(OpCodes.Ldarg_1); // TK key
                methodGen.Emit(OpCodes.Callvirt, definition.FieldType.GetMethod("Invoke", new[] { definition.ParameterType })); // _methodName.Invoke(key)
                methodGen.Emit(OpCodes.Ret); // Return result
            }
            
            ctorGen.Emit(OpCodes.Ret);

            return typeBuilder.CreateTypeInfo();
        }

        private static void ValidateType(Type type)
        {
            if (!type.IsInterface)
                throw new InvalidOperationException("<T> must be an interface");

            foreach (var methodInfo in type.GetMethods())
            {
                var parameters = methodInfo.GetParameters();
                if (parameters.Length != 1)
                    throw new Exception("Method must have exactly 1 input");

                var returnType = methodInfo.ReturnType;
                if (returnType == typeof(void) || returnType == typeof(Task))
                {
                    throw new Exception($@"
Method must return a value. '{type.FullName}.{methodInfo.Name}' returns '{returnType.Name}'");
                }
            }
        }

        private static MethodDefinition GetMethodDefinition(MethodInfo methodInfo)
        {
            var messageFormat = $"Invalid method signature. {{0}}. Method: '{methodInfo.Name}'";
            
            if (methodInfo.GetParameters().Length != 1)
                throw new Exception(String.Format(messageFormat, "Method must have a single input parameter"));

            var funcType = typeof(Func<,>).MakeGenericType(
                methodInfo.GetParameters().Single().ParameterType,
                methodInfo.ReturnType);
            
            var parameterType = methodInfo.GetParameters().First().ParameterType;

            var isMultiKey = parameterType != typeof(String) && typeof(IEnumerable).IsAssignableFrom(parameterType);
            var isAsync = typeof(Task).IsAssignableFrom(methodInfo.ReturnType);
            
            Type keyType;
            if (isMultiKey)
            {
                if (parameterType.GenericTypeArguments.Length != 1)
                    throw new Exception(String.Format(messageFormat, "Enumerable parameters must have a single generic type argument"));

                keyType = parameterType.GenericTypeArguments.Single();
            }
            else
            {
                keyType = parameterType;
            }
            
            var returnType = methodInfo.ReturnType;
            var returnTypeInner = isAsync
                ? returnType.GenericTypeArguments.Single()
                : returnType;

            Type valueType;
            Type fieldType;
            if (isMultiKey)
            {
                if (returnTypeInner.GenericTypeArguments.Length != 2)
                    throw new Exception(String.Format(messageFormat, "Return type must derive from IDictionary<TK, TV>"));

                if (returnTypeInner.GenericTypeArguments.First() != keyType)
                    throw new Exception(String.Format(messageFormat, "The key type in the returned dictionary must match the type of the items in the input parameter"));

                valueType = returnTypeInner.GenericTypeArguments.Last();

                var dictionaryType = typeof(IDictionary<,>).MakeGenericType(keyType, valueType);
                
                if (!dictionaryType.IsAssignableFrom(returnTypeInner))
                    throw new Exception(String.Format(messageFormat, "Return type must derive from IDictionary<TK, TV>"));

                var multiParamType = typeof(IEnumerable<>).MakeGenericType(keyType);
                var multiReturnType = typeof(Task<>).MakeGenericType(dictionaryType);
                
                fieldType = typeof(Func<,>).MakeGenericType(multiParamType, multiReturnType);
            }
            else
            {
                valueType = returnTypeInner;

                fieldType = typeof(Func<,>).MakeGenericType(parameterType, returnType);
            }

            return new MethodDefinition
            {
                FuncType = funcType,
                ParameterType = parameterType,
                ReturnType = returnType,
                ReturnTypeInner = returnTypeInner,
                KeyType = keyType,
                ValueType = valueType,
                FieldType = fieldType,
                IsMultiKey = isMultiKey,
                IsAsync = isAsync
            };
        }

        private static Type GetConfigManagerType(MethodDefinition definition)
        {
            Type type;
            if (definition.IsMultiKey)
            {
                type = definition.IsAsync
                    ? typeof(MultiKeyFunctionCacheConfigurationManager<,,,>)
                    : typeof(MultiKeyFunctionCacheConfigurationManagerSync<,,,>);

                return type.MakeGenericType(definition.ParameterType, definition.ReturnTypeInner, definition.KeyType, definition.ValueType);
            }
            
            type = definition.IsAsync
                ? typeof(FunctionCacheConfigurationManager<,>)
                : typeof(FunctionCacheConfigurationManagerSync<,>);
            
            return type.MakeGenericType(definition.KeyType, definition.ValueType);
        }

        private static string GetProxyName(Type type)
        {
            var name = $"{type.Namespace}.{type.Name.Remove(0, type.Name.StartsWith("I") ? 1 : 0)}Proxy_{Guid.NewGuid()}";

            return name;
        }

        private class MethodDefinition
        {
            public Type FuncType;
            public Type ParameterType;
            public Type ReturnType;
            public Type ReturnTypeInner;
            public Type KeyType;
            public Type ValueType;
            public Type FieldType;
            public bool IsMultiKey;
            public bool IsAsync;
        }
    }
}