using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using CacheMeIfYouCan.Configuration;

[assembly: InternalsVisibleTo("ProxyFactoryAsm")]
[assembly: InternalsVisibleTo("CacheMeIfYouCan.Tests")]
namespace CacheMeIfYouCan.Internal
{
    internal class CachedProxyFactory
    {
        private static readonly ModuleBuilder ModuleBuilder;
        
        static CachedProxyFactory()
        {
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyFactoryAsm"), AssemblyBuilderAccess.Run);
            ModuleBuilder = assemblyBuilder.DefineDynamicModule("MainModule");
        }

        internal static T Build<T>(T impl, CachedProxyConfig config)
        {
            var interfaceType = typeof(T);

            ValidateType(interfaceType);
            
            var newTypeName = GetProxyName(interfaceType);

            var newType = CreateType(interfaceType, newTypeName);

            return (T)Activator.CreateInstance(newType, impl, config);
        }

        // The IL generated here is based on the IL generated by SampleProxyILTemplate
        private static Type CreateType(Type interfaceType, string name)
        {
            var typeBuilder = ModuleBuilder.DefineType(name, TypeAttributes.Class | TypeAttributes.Public);
            typeBuilder.AddInterfaceImplementation(interfaceType);
            
            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[] { interfaceType, typeof(CachedProxyConfig) });

            var ctorGen = ctorBuilder.GetILGenerator();

            foreach (var methodInfo in interfaceType.GetMethods())
            {
                var definition = GetMethodDefinition(methodInfo);
                
                // Create a field called _methodName of type Func<TK, Task<TV>> in which to store the cached function
                var fieldType = typeof(Func<,>).MakeGenericType(definition.ParameterType, definition.ReturnType);
                var fieldName = $"_{Char.ToLower(methodInfo.Name[0])}{methodInfo.Name.Substring(1)}";
                var field = typeBuilder.DefineField(fieldName, fieldType, FieldAttributes.Private);
                var fieldCtor = fieldType.GetConstructor(new[] { typeof(object), typeof(IntPtr) });
                
                // Either FunctionCacheConfigurationManager<TK, TV> or MultiKeyFunctionCacheConfigurationManager
                // depending on if the key is Enumerable or not
                var configManagerType = definition.IsMultiKey
                    ? typeof(MultiKeyFunctionCacheConfigurationManager<,>).MakeGenericType(definition.KeyType, definition.ValueType)
                    : typeof(FunctionCacheConfigurationManager<,>).MakeGenericType(definition.KeyType, definition.ValueType);
                
                var configManagerTypeCtor = configManagerType.GetConstructor(
                    BindingFlags.Instance | BindingFlags.NonPublic,
                    null,
                    new[] { fieldType, typeof(string), typeof(CachedProxyConfig) },
                    new ParameterModifier[0]);
                
                // Build a cached version of the function and store it in the newly created field
                ctorGen.Emit(OpCodes.Ldarg_0); // this
                ctorGen.Emit(OpCodes.Ldarg_1); // T impl
                ctorGen.Emit(OpCodes.Dup);
                ctorGen.Emit(OpCodes.Ldvirtftn, methodInfo); // impl.MethodName
                ctorGen.Emit(OpCodes.Newobj, fieldCtor); // Func<TK, Task<TV>> .ctor(object, IntPointer)
                ctorGen.Emit(OpCodes.Ldstr, methodInfo.Name); // MethodName
                ctorGen.Emit(OpCodes.Ldarg_2); // CachedProxyConfig config
                ctorGen.Emit(OpCodes.Newobj, configManagerTypeCtor); // FunctionCacheConfigurationManager .ctor(Func<TK, Task<TV>>, string, CachedProxyConfig)
                ctorGen.Emit(OpCodes.Call, configManagerType.GetMethod("Build")); // FunctionCacheConfigurationManager.Build()
                ctorGen.Emit(OpCodes.Stfld, field); // Store result in _methodName
                
                // Build a method to implement the interface method by calling the function stored in the newly created field
                var methodBuilder = typeBuilder.DefineMethod(
                    methodInfo.Name,
                    MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                    methodInfo.ReturnType,
                    new[] { definition.ParameterType });
                
                var methodGen = methodBuilder.GetILGenerator();
                
                methodGen.Emit(OpCodes.Ldarg_0); // this
                methodGen.Emit(OpCodes.Ldfld, field); // _methodName
                methodGen.Emit(OpCodes.Ldarg_1); // TK key
                methodGen.Emit(OpCodes.Callvirt, fieldType.GetMethod("Invoke", new[] { definition.ParameterType })); // _methodName.Invoke(key)
                methodGen.Emit(OpCodes.Ret); // Return result
            }
            
            ctorGen.Emit(OpCodes.Ret);

            return typeBuilder.CreateTypeInfo();
        }

        private static void ValidateType(Type type)
        {
            if (!type.IsInterface)
                throw new InvalidOperationException("<T> must be an interface");

            foreach (var methodInfo in type.GetMethods())
            {
                var parameters = methodInfo.GetParameters();
                if (parameters.Length != 1)
                    throw new Exception("Method must have exactly 1 input");

                var returnType = methodInfo.ReturnType;
                if (returnType.GetGenericTypeDefinition() != typeof(Task<>))
                    throw new Exception("Method must return Task<T>");
            }
        }

        private static MethodDefinition GetMethodDefinition(MethodInfo methodInfo)
        {
            var messageFormat = $"Invalid method signature. {{0}}. Method: '{methodInfo.Name}'";
            
            if (methodInfo.GetParameters().Length > 1)
                throw new Exception(String.Format(messageFormat, "Method must have a single input parameter"));
            
            var parameterType = methodInfo.GetParameters().First().ParameterType;

            var isMultiKey = parameterType != typeof(String) && typeof(IEnumerable).IsAssignableFrom(parameterType);

            Type keyType;
            if (isMultiKey)
            {
                if (parameterType.GenericTypeArguments.Length != 1)
                    throw new Exception(String.Format(messageFormat, "Enumerable parameters must have a single generic type argument"));

                keyType = parameterType.GenericTypeArguments.Single();
            }
            else
            {
                keyType = parameterType;
            }
            
            var returnType = methodInfo.ReturnType;
            
            if (!typeof(Task).IsAssignableFrom(returnType) || returnType.GenericTypeArguments.Length != 1)
                throw new Exception(String.Format(messageFormat, "Return type must be a Task<T>"));
            
            var returnTypeInner = returnType.GenericTypeArguments.Single();

            Type valueType;
            if (isMultiKey)
            {
                if (returnTypeInner.GenericTypeArguments.Length != 2)
                    throw new Exception(String.Format(messageFormat, "Return type must derive from IDictionary<TK, TV>"));

                if (returnTypeInner.GenericTypeArguments.First() != keyType)
                    throw new Exception(String.Format(messageFormat, "The key type in the returned dictionary must match the type of the items in the input parameter"));

                valueType = returnTypeInner.GenericTypeArguments.Last();

                var dictionaryType = typeof(IDictionary<,>).MakeGenericType(keyType, valueType);
                
                if (!dictionaryType.IsAssignableFrom(returnTypeInner))
                    throw new Exception(String.Format(messageFormat, "Return type must derive from IDictionary<TK, TV>"));
            }
            else
            {
                valueType = returnTypeInner;
            }

            return new MethodDefinition
            {
                ParameterType = parameterType,
                ReturnType = returnType,
                ReturnTypeInner = returnTypeInner,
                KeyType = keyType,
                ValueType = valueType,
                IsMultiKey = isMultiKey
            };
        }

        private static string GetProxyName(Type type)
        {
            var name = $"{type.Namespace}.{type.Name.Remove(0, type.Name.StartsWith("I") ? 1 : 0)}Proxy_{Guid.NewGuid()}";

            return name;
        }

        private class MethodDefinition
        {
            public Type ParameterType;
            public Type ReturnType;
            public Type ReturnTypeInner;
            public Type KeyType;
            public Type ValueType;
            public bool IsMultiKey;
        }
    }
}